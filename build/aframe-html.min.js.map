{"version":3,"file":"aframe-html.min.js","sources":["../src/HTMLMesh.js","../src/aframe-html.js"],"sourcesContent":["/* jshint esversion: 9, -W097, unused: true */\n/* For dealing with spline curves */\n/* global setTimeout, MutationObserver, clearTimeout,document,Node,HTMLCanvasElement, window,MouseEvent, HTMLInputElement */\n'use strict';\n\nimport {\n\tCanvasTexture,\n\tLinearFilter,\n\tMesh,\n\tMeshBasicMaterial,\n\tPlaneGeometry,\n\tsRGBEncoding\n} from 'three';\n\nclass HTMLMesh extends Mesh {\n\n\tconstructor( dom ) {\n\n\t\tconst texture = new HTMLTexture( dom );\n\n\t\tconst geometry = new PlaneGeometry( texture.image.width * 0.001, texture.image.height * 0.001 );\n\t\tconst material = new MeshBasicMaterial( { map: texture, toneMapped: false, transparent: true } );\n\n\t\tsuper( geometry, material );\n\n\t\tfunction onEvent( event ) {\n\n\t\t\tmaterial.map.dispatchDOMEvent( event );\n\n\t\t}\n\n\t\tthis.addEventListener( 'mousedown', onEvent );\n\t\tthis.addEventListener( 'mousemove', onEvent );\n\t\tthis.addEventListener( 'mouseup', onEvent );\n\t\tthis.addEventListener( 'click', onEvent );\n\n\t\tthis.dispose = function () {\n\n\t\t\tgeometry.dispose();\n\t\t\tmaterial.dispose();\n\n\t\t\tmaterial.map.dispose();\n\n\t\t\tthis.removeEventListener( 'mousedown', onEvent );\n\t\t\tthis.removeEventListener( 'mousemove', onEvent );\n\t\t\tthis.removeEventListener( 'mouseup', onEvent );\n\t\t\tthis.removeEventListener( 'click', onEvent );\n\n\t\t};\n\n\t}\n\n}\n\nclass HTMLTexture extends CanvasTexture {\n\n\tconstructor( dom ) {\n\n\t\tsuper( html2canvas( dom ) );\n\n\t\tthis.dom = dom;\n\n\t\tthis.anisotropy = 16;\n\t\tthis.encoding = sRGBEncoding;\n\t\tthis.minFilter = LinearFilter;\n\t\tthis.magFilter = LinearFilter;\n\n\t\t// Create an observer on the DOM, and run html2canvas update in the next loop\n\t\tconst observer = new MutationObserver( () => {\n\n\t\t\tif ( ! this.scheduleUpdate ) {\n\n\t\t\t\t// ideally should use xr.requestAnimationFrame, here setTimeout to avoid passing the renderer\n\t\t\t\tthis.scheduleUpdate = setTimeout( () => this.update(), 16 );\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst config = { attributes: true, childList: true, subtree: true, characterData: true };\n\t\tobserver.observe( dom, config );\n\n\t\tthis.observer = observer;\n\n\t}\n\n\tdispatchDOMEvent( event ) {\n\n\t\tif ( event.data ) {\n\n\t\t\thtmlevent( this.dom, event.type, event.data.x, event.data.y );\n\n\t\t}\n\n\t}\n\n\tupdate() {\n\n\t\tthis.image = html2canvas( this.dom );\n\t\tthis.needsUpdate = true;\n\n\t\tthis.scheduleUpdate = null;\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this.observer ) {\n\n\t\t\tthis.observer.disconnect();\n\n\t\t}\n\n\t\tthis.scheduleUpdate = clearTimeout( this.scheduleUpdate );\n\n\t\tsuper.dispose();\n\n\t}\n\n}\n\nfunction fillRoundRect(ctx, x, y, w, h, r) {\n\tif (w < 2 * r) r = w / 2;\n\tif (h < 2 * r) r = h / 2;\n\tctx.beginPath();\n\tctx.moveTo(x+r, y);\n\tctx.arcTo(x+w, y,   x+w, y+h, r);\n\tctx.arcTo(x+w, y+h, x,   y+h, r);\n\tctx.arcTo(x,   y+h, x,   y,   r);\n\tctx.arcTo(x,   y,   x+w, y,   r);\n\tctx.closePath();\n\tctx.fill();\n\treturn ctx;\n}\n\nconst canvases = new WeakMap();\n\nfunction html2canvas( element ) {\n\n\tconst range = document.createRange();\n\n\tfunction Clipper( context ) {\n\n\t\tconst clips = [];\n\t\tlet isClipping = false;\n\n\t\tfunction doClip() {\n\n\t\t\tif ( isClipping ) {\n\n\t\t\t\tisClipping = false;\n\t\t\t\tcontext.restore();\n\n\t\t\t}\n\n\t\t\tif ( clips.length === 0 ) return;\n\n\t\t\tlet minX = - Infinity, minY = - Infinity;\n\t\t\tlet maxX = Infinity, maxY = Infinity;\n\n\t\t\tfor ( let i = 0; i < clips.length; i ++ ) {\n\n\t\t\t\tconst clip = clips[ i ];\n\n\t\t\t\tminX = Math.max( minX, clip.x );\n\t\t\t\tminY = Math.max( minY, clip.y );\n\t\t\t\tmaxX = Math.min( maxX, clip.x + clip.width );\n\t\t\t\tmaxY = Math.min( maxY, clip.y + clip.height );\n\n\t\t\t}\n\n\t\t\tcontext.save();\n\t\t\tcontext.beginPath();\n\t\t\tcontext.rect( minX, minY, maxX - minX, maxY - minY );\n\t\t\tcontext.clip();\n\n\t\t\tisClipping = true;\n\n\t\t}\n\n\t\treturn {\n\n\t\t\tadd: function ( clip ) {\n\n\t\t\t\tclips.push( clip );\n\t\t\t\tdoClip();\n\n\t\t\t},\n\n\t\t\tremove: function () {\n\n\t\t\t\tclips.pop();\n\t\t\t\tdoClip();\n\n\t\t\t}\n\n\t\t};\n\n\t}\n\n\tfunction drawText( style, x, y, string ) {\n\n\t\tif ( string !== '' ) {\n\n\t\t\tif ( style.textTransform === 'uppercase' ) {\n\n\t\t\t\tstring = string.toUpperCase();\n\n\t\t\t}\n\n\t\t\tcontext.font = style.fontSize + ' ' + style.fontFamily;\n\t\t\tcontext.textBaseline = 'top';\n\t\t\tcontext.fillStyle = style.color;\n\t\t\tcontext.fillText( string, x, y + parseFloat(style.fontSize)*0.1 );\n\n\t\t}\n\n\t}\n\n\tfunction drawBorder( style, which, x, y, width, height ) {\n\n\t\tconst borderWidth = style[ which + 'Width' ];\n\t\tconst borderStyle = style[ which + 'Style' ];\n\t\tconst borderColor = style[ which + 'Color' ];\n\n\t\tif ( borderWidth !== '0px' && borderStyle !== 'none' && borderColor !== 'transparent' && borderColor !== 'rgba(0, 0, 0, 0)' ) {\n\n\t\t\tcontext.strokeStyle = borderColor;\n\t\t\tcontext.lineWidth = parseFloat(borderWidth);\n\t\t\tcontext.beginPath();\n\t\t\tcontext.moveTo( x, y );\n\t\t\tcontext.lineTo( x + width, y + height );\n\t\t\tcontext.stroke();\n\n\t\t}\n\n\t}\n\n\tfunction drawElement( element, style ) {\n\n\t\tlet x = 0, y = 0, width = 0, height = 0;\n\n\t\tif ( element.nodeType === Node.TEXT_NODE ) {\n\n\t\t\t// text\n\n\t\t\trange.selectNode( element );\n\n\t\t\tconst rect = range.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\n\t\t\tdrawText( style, x, y, element.nodeValue.trim() );\n\n\t\t} else if ( element.nodeType === Node.COMMENT_NODE ) {\n\n\t\t\treturn;\n\n\t\t} else if ( element instanceof HTMLCanvasElement ) {\n\n\t\t\t// Canvas element\n\t\t\tif ( element.style.display === 'none' ) return;\n\n\t\t\tcontext.save();\n\t\t\tconst dpr = window.devicePixelRatio;\n\t\t\tcontext.scale(1/dpr, 1/dpr);\n\t\t\tcontext.drawImage(element, 0, 0 );\n\t\t\tcontext.restore();\n\n\t\t} else {\n\t\t\tif ( element.style.display === 'none' ) return;\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tx = rect.left - offset.left - 0.5;\n\t\t\ty = rect.top - offset.top - 0.5;\n\t\t\twidth = rect.width;\n\t\t\theight = rect.height;\n\n\t\t\tstyle = window.getComputedStyle( element );\n\n\t\t\tconst backgroundColor = style.backgroundColor;\n\n\t\t\tif ( element instanceof HTMLInputElement && element.type === 'radio') {\n\n\t\t\t}\n\n\t\t\tif ( backgroundColor !== 'transparent' && backgroundColor !== 'rgba(0, 0, 0, 0)' ) {\n\n\t\t\t\tcontext.fillStyle = backgroundColor;\n\t\t\t\tfillRoundRect( context, x, y, width, height, parseFloat(style.borderRadius) );\n\n\t\t\t}\n\n\t\t\tconst borders = ['borderTop', 'borderLeft', 'borderBottom', 'borderRight'];\n\t\t\tlet match = true;\n\t\t\tlet prevBorder = null;\n\t\t\tfor (const border of borders) {\n\t\t\t\tif (prevBorder) {\n\t\t\t\t\tmatch = match && style[ border + 'Width' ] && style[ border + 'Color' ] && style[ border + 'Style'];\n\t\t\t\t}\n\t\t\t\tif (!match) break;\n\t\t\t\tprevBorder = border;\n\t\t\t}\n\n\t\t\t// they all match so stroke the rectangle from before\n\t\t\tif (match) {\n\t\t\t\tconst width = parseFloat(style.borderTopWidth);\n\t\t\t\tif ( style.borderTopWidth !== '0px' && style.borderTopStyle !== 'none' && style.borderTopColor !== 'transparent' && style.borderTopColor !== 'rgba(0, 0, 0, 0)' ) {\n\t\t\t\t\tcontext.strokeStyle = style.borderTopColor;\n\t\t\t\t\tcontext.lineWidth = width;\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdrawBorder( style, 'borderTop', x, y, width, 0 );\n\t\t\t\tdrawBorder( style, 'borderLeft', x, y, 0, height );\n\t\t\t\tdrawBorder( style, 'borderBottom', x, y + height, width, 0 );\n\t\t\t\tdrawBorder( style, 'borderRight', x + width, y, 0, height );\n\t\t\t}\n\n\t\t\tif ( element instanceof HTMLInputElement) {\n\n\t\t\t\tlet accentColor = style.accentColor;\n\t\t\t\tif (accentColor === undefined || accentColor === 'auto') accentColor = style.color;\n\n\t\t\t\tif (element.type  === 'radio') {\n\t\t\t\t\tconst border = 2;\n\t\t\t\t\t// Draw handle\n\t\t\t\t\tcontext.fillStyle = 'white';\n\t\t\t\t\tfillRoundRect(context, x,y,width,height,height);\n\t\t\t\t\tcontext.strokeStyle = accentColor;\n\t\t\t\t\tcontext.lineWidth = 1;\n\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t\t\n\t\t\t\t\tif (element.checked) {\n\t\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\t\tfillRoundRect(context, x+border,y+border,width-border*2,height-border*2, height);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (element.type  === 'range') {\n\t\t\t\t\t// Draw handle\n\t\t\t\t\tconst [min,max,value] = ['min','max','value'].map(property => parseFloat(element[property]));\n\t\t\t\t\tconst position = ((value-min)/(max-min)) * (width - height);\n\t\t\t\t\t\n\t\t\t\t\tcontext.fillStyle = '#333333';\n\t\t\t\t\tfillRoundRect(context, x,y + height*0.25,width, height*0.5, height*0.25);\n\t\t\t\t\tcontext.strokeStyle = accentColor;\n\t\t\t\t\tcontext.lineWidth = 1;\n\t\t\t\t\tcontext.stroke();\n\n\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\tfillRoundRect(context, x,y + height*0.25,position+height*0.5, height*0.5, height*0.25);\n\n\t\t\t\t\tcontext.fillStyle = accentColor;\n\t\t\t\t\tfillRoundRect(context, x + position,y,height, height, height*0.5);\n\t\t\t\t}\n\n\t\t\t\tif (element.type === 'color' || element.type === 'text' || element.type === 'number' ) {\n\n\t\t\t\t\tclipper.add( { x: x, y: y, width: width, height: height } );\n\n\t\t\t\t\tdrawText( style, x + parseInt( style.paddingLeft ), y + parseInt( style.paddingTop ), element.value );\n\n\t\t\t\t\tclipper.remove();\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\t/*\n\t\t// debug\n\t\tcontext.strokeStyle = '#' + Math.random().toString( 16 ).slice( - 3 );\n\t\tcontext.strokeRect( x - 0.5, y - 0.5, width + 1, height + 1 );\n\t\t*/\n\n\t\tconst isClipping = style.overflow === 'auto' || style.overflow === 'hidden';\n\n\t\tif ( isClipping ) clipper.add( { x: x, y: y, width: width, height: height } );\n\n\t\tfor ( let i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\tdrawElement( element.childNodes[ i ], style );\n\n\t\t}\n\n\t\tif ( isClipping ) clipper.remove();\n\n\t}\n\n\tconst offset = element.getBoundingClientRect();\n\n\tlet canvas;\n\n\tif ( canvases.has( element ) ) {\n\n\t\tcanvas = canvases.get( element );\n\n\t} else {\n\n\t\tcanvas = document.createElement( 'canvas' );\n\t\tcanvas.width = offset.width;\n\t\tcanvas.height = offset.height;\n\n\t}\n\n\tconst context = canvas.getContext( '2d'/*, { alpha: false }*/ );\n\n\tconst clipper = new Clipper( context );\n\n\t// console.time( 'drawElement' );\n\n\tdrawElement( element );\n\n\t// console.timeEnd( 'drawElement' );\n\n\treturn canvas;\n\n}\n\nfunction htmlevent( element, event, x, y ) {\n\n\tconst mouseEventInit = {\n\t\tclientX: ( x * element.offsetWidth ) + element.offsetLeft,\n\t\tclientY: ( y * element.offsetHeight ) + element.offsetTop,\n\t\tview: element.ownerDocument.defaultView\n\t};\n\n\twindow.dispatchEvent( new MouseEvent( event, mouseEventInit ) );\n\n\tconst rect = element.getBoundingClientRect();\n\n\tx = x * rect.width + rect.left;\n\ty = y * rect.height + rect.top;\n\n\tfunction traverse( element ) {\n\n\t\tif ( element.nodeType !== Node.TEXT_NODE && element.nodeType !== Node.COMMENT_NODE ) {\n\n\t\t\tconst rect = element.getBoundingClientRect();\n\n\t\t\tif ( x > rect.left && x < rect.right && y > rect.top && y < rect.bottom ) {\n\n\t\t\t\telement.dispatchEvent( new MouseEvent( event, mouseEventInit ) );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < element.childNodes.length; i ++ ) {\n\n\t\t\t\ttraverse( element.childNodes[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\ttraverse( element );\n\n}\n\nexport { HTMLMesh };\n","/* jshint esversion: 9, -W097 */\n/* For dealing with spline curves */\n/* global THREE, AFRAME, setTimeout */\n'use strict';\n\nimport { HTMLMesh } from './HTMLMesh.js';\n\nconst schema = {\n\ttype: 'selector',\n};\n\ndocumentation:{\n\tschema.description = `HTML element to use.`;\n\tconsole.log(`Display an interactive HTML element in the scene.`);\n}\n\nAFRAME.registerComponent('html', {\n\tschema: schema,\n\tinit() {\n\t\tthis.rerender = this.rerender.bind(this);\n\t},\n\tupdate() {\n\t\tthis.remove();\n\t\tif (!this.data) return;\n\t\tconst mesh = new HTMLMesh(this.data);\n\t\tthis.el.setObject3D('html', mesh);\n\t\tthis.data.addEventListener('input', this.rerender);\n\t},\n\trerender() {\n\t\tconst mesh = this.el.getObject3D('html');\n\t\tif (mesh && !mesh.material.map.scheduleUpdate) {\n\t\t\tmesh.material.map.scheduleUpdate = setTimeout( () => mesh.material.map.update(), 16 );\n\t\t}\n\t},\n\tremove() {\n\t\tif (this.el.getObject3D('html')) {\n\t\t\tthis.el.removeObject3D('html');\n\t\t\tthis.observer.disconnect();\n\t\t\tthis.data.removeEventListener('change', this.rerender);\n\t\t}\n\t}\n});\n"],"names":["HTMLMesh","Mesh","constructor","dom","texture","HTMLTexture","geometry","PlaneGeometry","image","width","height","material","MeshBasicMaterial","map","toneMapped","transparent","onEvent","event","dispatchDOMEvent","super","this","addEventListener","dispose","removeEventListener","CanvasTexture","html2canvas","anisotropy","encoding","sRGBEncoding","minFilter","LinearFilter","magFilter","observer","MutationObserver","scheduleUpdate","setTimeout","update","observe","attributes","childList","subtree","characterData","data","element","x","y","mouseEventInit","clientX","offsetWidth","offsetLeft","clientY","offsetHeight","offsetTop","view","ownerDocument","defaultView","window","dispatchEvent","MouseEvent","rect","getBoundingClientRect","traverse","nodeType","Node","TEXT_NODE","COMMENT_NODE","left","right","top","bottom","i","childNodes","length","htmlevent","type","needsUpdate","disconnect","clearTimeout","fillRoundRect","ctx","w","h","r","beginPath","moveTo","arcTo","closePath","fill","canvases","WeakMap","range","document","createRange","drawText","style","string","textTransform","toUpperCase","context","font","fontSize","fontFamily","textBaseline","fillStyle","color","fillText","parseFloat","drawBorder","which","borderWidth","borderStyle","borderColor","strokeStyle","lineWidth","lineTo","stroke","offset","canvas","has","get","createElement","getContext","clipper","clips","isClipping","doClip","restore","minX","Infinity","minY","maxX","maxY","clip","Math","max","min","save","add","push","remove","pop","drawElement","selectNode","nodeValue","trim","HTMLCanvasElement","display","dpr","devicePixelRatio","scale","drawImage","backgroundColor","getComputedStyle","HTMLInputElement","borderRadius","borders","match","prevBorder","border","borderTopWidth","borderTopStyle","borderTopColor","accentColor","undefined","checked","value","property","position","parseInt","paddingLeft","paddingTop","overflow","AFRAME","registerComponent","schema","init","rerender","bind","mesh","el","setObject3D","getObject3D","removeObject3D"],"mappings":"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"}